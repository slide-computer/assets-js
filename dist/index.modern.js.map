{"version":3,"file":"index.modern.js","sources":["../src/did/asset_canister.did.js","../src/index.ts","../src/did/index.js"],"sourcesContent":["export const idlFactory = ({IDL}) => {\n    const ClearArguments = IDL.Record({});\n    const BatchId = IDL.Nat;\n    const Key = IDL.Text;\n    const CreateAssetArguments = IDL.Record({\n        'key': Key,\n        'content_type': IDL.Text,\n    });\n    const UnsetAssetContentArguments = IDL.Record({\n        'key': Key,\n        'content_encoding': IDL.Text,\n    });\n    const DeleteAssetArguments = IDL.Record({'key': Key});\n    const ChunkId = IDL.Nat;\n    const SetAssetContentArguments = IDL.Record({\n        'key': Key,\n        'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\n        'chunk_ids': IDL.Vec(ChunkId),\n        'content_encoding': IDL.Text,\n    });\n    const BatchOperationKind = IDL.Variant({\n        'CreateAsset': CreateAssetArguments,\n        'UnsetAssetContent': UnsetAssetContentArguments,\n        'DeleteAsset': DeleteAssetArguments,\n        'SetAssetContent': SetAssetContentArguments,\n        'Clear': ClearArguments,\n    });\n    const HeaderField = IDL.Tuple(IDL.Text, IDL.Text);\n    const HttpRequest = IDL.Record({\n        'url': IDL.Text,\n        'method': IDL.Text,\n        'body': IDL.Vec(IDL.Nat8),\n        'headers': IDL.Vec(HeaderField),\n    });\n    const StreamingCallbackToken = IDL.Record({\n        'key': Key,\n        'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\n        'index': IDL.Nat,\n        'content_encoding': IDL.Text,\n    });\n    const StreamingCallbackHttpResponse = IDL.Record({\n        'token': IDL.Opt(StreamingCallbackToken),\n        'body': IDL.Vec(IDL.Nat8),\n    });\n    const StreamingStrategy = IDL.Variant({\n        'Callback': IDL.Record({\n            'token': StreamingCallbackToken,\n            'callback': IDL.Func(\n                [StreamingCallbackToken],\n                [IDL.Opt(StreamingCallbackHttpResponse)],\n                ['query'],\n            ),\n        }),\n    });\n    const HttpResponse = IDL.Record({\n        'body': IDL.Vec(IDL.Nat8),\n        'headers': IDL.Vec(HeaderField),\n        'streaming_strategy': IDL.Opt(StreamingStrategy),\n        'status_code': IDL.Nat16,\n    });\n    const Time = IDL.Int;\n    return IDL.Service({\n        'authorize': IDL.Func([IDL.Principal], [], []),\n        'clear': IDL.Func([ClearArguments], [], []),\n        'commit_batch': IDL.Func(\n            [\n                IDL.Record({\n                    'batch_id': BatchId,\n                    'operations': IDL.Vec(BatchOperationKind),\n                }),\n            ],\n            [],\n            [],\n        ),\n        'create_asset': IDL.Func([CreateAssetArguments], [], []),\n        'create_batch': IDL.Func(\n            [IDL.Record({})],\n            [IDL.Record({'batch_id': BatchId})],\n            [],\n        ),\n        'create_chunk': IDL.Func(\n            [IDL.Record({'content': IDL.Vec(IDL.Nat8), 'batch_id': BatchId})],\n            [IDL.Record({'chunk_id': ChunkId})],\n            [],\n        ),\n        'delete_asset': IDL.Func([DeleteAssetArguments], [], []),\n        'get': IDL.Func(\n            [IDL.Record({'key': Key, 'accept_encodings': IDL.Vec(IDL.Text)})],\n            [\n                IDL.Record({\n                    'content': IDL.Vec(IDL.Nat8),\n                    'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\n                    'content_type': IDL.Text,\n                    'content_encoding': IDL.Text,\n                    'total_length': IDL.Nat,\n                }),\n            ],\n            ['query'],\n        ),\n        'get_chunk': IDL.Func(\n            [\n                IDL.Record({\n                    'key': Key,\n                    'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\n                    'index': IDL.Nat,\n                    'content_encoding': IDL.Text,\n                }),\n            ],\n            [IDL.Record({'content': IDL.Vec(IDL.Nat8)})],\n            ['query'],\n        ),\n        'http_request': IDL.Func([HttpRequest], [HttpResponse], ['query']),\n        'http_request_streaming_callback': IDL.Func(\n            [StreamingCallbackToken],\n            [IDL.Opt(StreamingCallbackHttpResponse)],\n            ['query'],\n        ),\n        'list': IDL.Func(\n            [IDL.Record({})],\n            [\n                IDL.Vec(\n                    IDL.Record({\n                        'key': Key,\n                        'encodings': IDL.Vec(\n                            IDL.Record({\n                                'modified': Time,\n                                'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\n                                'length': IDL.Nat,\n                                'content_encoding': IDL.Text,\n                            })\n                        ),\n                        'content_type': IDL.Text,\n                    })\n                ),\n            ],\n            ['query'],\n        ),\n        'set_asset_content': IDL.Func([SetAssetContentArguments], [], []),\n        'store': IDL.Func(\n            [\n                IDL.Record({\n                    'key': Key,\n                    'content': IDL.Vec(IDL.Nat8),\n                    'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\n                    'content_type': IDL.Text,\n                    'content_encoding': IDL.Text,\n                }),\n            ],\n            [],\n            [],\n        ),\n        'unset_asset_content': IDL.Func([UnsetAssetContentArguments], [], []),\n    });\n};","import {ActorConfig, hash} from \"@dfinity/agent\";\nimport {assetCanister} from \"./did\";\nimport mime from \"mime-types\";\nimport pLimit, {LimitFunction} from \"p-limit\";\n\ntype AssetCanister = ReturnType<typeof assetCanister>;\n\ninterface AssetManagerConfig extends ActorConfig {\n    concurrency?: number;\n    maxSingleFileSize?: number;\n    maxChunkSize?: number;\n    eventListener?: (event: AssetEvent) => void;\n}\n\ninterface Asset {\n    fileName: string;\n    path: string;\n    content: number[];\n    contentType: string;\n    contentEncoding: 'identity' | 'gzip' | 'compress' | 'deflate' | 'br';\n    sha256?: number[];\n}\n\ninterface AssetInsert {\n    (file: File, options?: Omit<Asset, 'fileName' | 'content' | 'contentType' | 'contentEncoding'> & Partial<Pick<Asset, 'fileName' | 'contentType' | 'contentEncoding'>>): Promise<string>;\n\n    (bytes: Blob | number[] | Uint8Array, options: Omit<Asset, 'content' | 'contentType' | 'contentEncoding'> & Partial<Pick<Asset, 'contentType' | 'contentEncoding'>>): Promise<string>;\n}\n\ninterface FileToAsset {\n    (...args: Parameters<AssetInsert>): Promise<Asset>;\n}\n\ninterface InsertAssetEvent {\n    key: string;\n    type: 'insert';\n    progress: {\n        current: number;\n        total: number;\n    };\n}\n\ninterface DeleteAssetEvent {\n    key: string;\n    type: 'delete';\n}\n\ntype AssetEvent = InsertAssetEvent | DeleteAssetEvent;\n\nconst isBrowser =\n    typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n\nconst isNode =\n    typeof process !== \"undefined\" &&\n    process.versions != null &&\n    process.versions.node != null;\n\nconst isWebWorker =\n    typeof self === \"object\" &&\n    self.constructor &&\n    self.constructor.name === \"DedicatedWorkerGlobalScope\";\n\nconst inputToAsset: FileToAsset = async (input, options) => {\n    let content: number[];\n    let fileName: string = options?.fileName as any;\n    let contentType: string = options?.contentType as any;\n    let path: string = options?.path ?? '/';\n    if (input instanceof Uint8Array) {\n        content = Array.from(input);\n    } else if (Array.isArray(input) && input.every(b => typeof b === 'number')) {\n        content = input;\n    } else if (input instanceof Blob) {\n        content = await new Promise((resolve) => {\n            const reader = new FileReader();\n            reader.addEventListener('load', () => {\n                resolve(Array.from(Uint8Array.from(reader.result as any)));\n            });\n            reader.readAsArrayBuffer(input);\n        });\n        if (!fileName) {\n            if (input instanceof File) {\n                fileName = input.name;\n            } else {\n                throw '\"fileName\" property is required in options';\n            }\n        }\n        if (!contentType) {\n            contentType = input.type;\n        }\n    } else {\n        throw 'Asset could not be read (File, Blob, ArrayBuffer, Uint8Array and number[] are valid';\n    }\n    if (!path.startsWith('/')) {\n        path = '/' + path;\n    }\n    if (!path.endsWith('/')) {\n        path = path + '/';\n    }\n    const contentEncoding = options?.contentEncoding ?? 'identity';\n    const sha256 = options?.sha256 ?? Array.from(new Uint8Array(hash(new Uint8Array(content))));\n\n    // If content type is not supplied in either the file or options, detect content type based on filename (extension)\n    if (!contentType) {\n        contentType = mime.lookup(fileName) || 'application/octet-stream';\n    }\n\n    return {\n        fileName,\n        path,\n        content,\n        contentType,\n        contentEncoding,\n        sha256,\n    };\n};\n\nexport class AssetManager {\n    private readonly _actor: AssetCanister;\n    private readonly _pLimit: LimitFunction;\n    private readonly _maxSingleFileSize: number;\n    private readonly _maxChunkSize: number;\n    private readonly _eventListener: (event: AssetEvent) => void;\n\n    constructor({concurrency, maxSingleFileSize, maxChunkSize, eventListener, ...actorConfig}: AssetManagerConfig) {\n        this._actor = assetCanister(actorConfig);\n        this._pLimit = pLimit(concurrency ?? 32);\n        this._maxSingleFileSize = maxSingleFileSize ?? 450000;\n        this._maxChunkSize = maxChunkSize ?? 1900000;\n        this._eventListener = eventListener ?? (() => null);\n    }\n\n    list = () => this._pLimit(() => this._actor.list({}));\n\n    batch = () => {\n        const scheduledOperations: Array<(batch_id: bigint) => Promise<Parameters<AssetCanister['commit_batch']>[0]['operations']>> = [];\n        const commit = async () => {\n            const {batch_id} = await this._pLimit(() => this._actor.create_batch({}));\n            const operations = (await Promise.all(scheduledOperations.map(scheduled_operation => scheduled_operation(batch_id)))).flat();\n            await this._pLimit(() => this._actor.commit_batch({batch_id, operations}));\n            operations.forEach(operation => {\n                if ('DeleteAsset' in operation) {\n                    this._eventListener({key: operation.DeleteAsset.key, type: 'delete'});\n                }\n            })\n        };\n        const insert: AssetInsert = async (input, options) => {\n            const asset = await inputToAsset(input, options);\n            const key = [asset.path, asset.fileName].join('');\n            this._eventListener({key, type: 'insert', progress: {current: 0, total: asset.content.length}});\n            scheduledOperations.push(async batch_id => {\n                const chunks = asset.content.reduce((chunks, byte, index) => {\n                    const chunkIndex = Math.floor(index / this._maxChunkSize)\n                    if (!chunks[chunkIndex]) {\n                        chunks[chunkIndex] = [];\n                    }\n                    chunks[chunkIndex].push(byte)\n                    return chunks;\n                }, [] as number[][]);\n                let progress = 0;\n                const chunkIds: bigint[] = await Promise.all(chunks\n                    .map(async chunk => {\n                        const {chunk_id} = await this._pLimit(() => this._actor.create_chunk({\n                            content: chunk,\n                            batch_id\n                        }));\n                        progress += chunk.length;\n                        this._eventListener({\n                            key,\n                            type: 'insert',\n                            progress: {current: progress, total: asset.content.length}\n                        });\n                        return chunk_id;\n                    })\n                );\n                return [\n                    {\n                        CreateAsset: {key, content_type: asset.contentType}\n                    },\n                    {\n                        SetAssetContent: {\n                            key,\n                            sha256: asset.sha256 ? [asset.sha256] : [],\n                            chunk_ids: chunkIds,\n                            content_encoding: asset.contentEncoding\n                        }\n                    },\n                ];\n            });\n            return key;\n        }\n        const _delete = async (key: string) => {\n            scheduledOperations.push(async () => [{DeleteAsset: {key}}]);\n        }\n\n        return {commit, insert, delete: _delete};\n    }\n\n    insert: AssetInsert = async (input, options) => {\n        const asset = await inputToAsset(input, options);\n        const key = [asset.path, asset.fileName].join('');\n\n        if (asset.content.length <= this._maxSingleFileSize) {\n            // Asset is small enough to be uploaded in one request\n            this._eventListener({key, type: 'insert', progress: {current: 0, total: asset.content.length}});\n            await this._pLimit(() => this._actor.store({\n                key,\n                content: asset.content,\n                content_type: asset.contentType,\n                sha256: asset.sha256 ? [asset.sha256] : [],\n                content_encoding: asset.contentEncoding\n            }));\n        } else {\n            // Create batch to upload asset in chunks\n            const batch = this.batch();\n            await batch.insert(asset.content, asset);\n            await batch.commit();\n        }\n\n        return key;\n    };\n\n    delete = async (key: string) => {\n        await this._pLimit(() => this._actor.delete_asset({key}));\n        this._eventListener({key, type: 'delete'});\n    }\n}","import {idlFactory} from './asset_canister.did.js';\nimport {Actor} from \"@dfinity/agent\";\n\n/**\n * @type {(configuration: import(\"@dfinity/agent\").ActorConfig) => import(\"@dfinity/agent\").ActorSubclass<import(\"./asset_canister.did.js\")._SERVICE>}\n */\nexport const assetCanister = (configuration) => Actor.createActor(idlFactory, configuration);\n"],"names":["IDL","ClearArguments","Record","BatchId","Nat","Key","Text","CreateAssetArguments","key","content_type","UnsetAssetContentArguments","content_encoding","DeleteAssetArguments","ChunkId","SetAssetContentArguments","sha256","Opt","Vec","Nat8","chunk_ids","BatchOperationKind","Variant","CreateAsset","UnsetAssetContent","DeleteAsset","SetAssetContent","Clear","HeaderField","Tuple","url","method","body","headers","StreamingCallbackToken","index","token","Callback","callback","Func","StreamingCallbackHttpResponse","HttpResponse","streaming_strategy","StreamingStrategy","status_code","Nat16","Time","Int","Service","authorize","Principal","clear","commit_batch","batch_id","operations","create_asset","create_batch","create_chunk","content","chunk_id","delete_asset","get","accept_encodings","total_length","get_chunk","http_request","HttpRequest","http_request_streaming_callback","list","encodings","modified","length","set_asset_content","store","unset_asset_content","_excluded","process","versions","inputToAsset","async","input","options","_options$path","_options$contentEncod","_options$sha","fileName","contentType","path","Uint8Array","Array","from","isArray","every","b","Blob","Promise","resolve","reader","FileReader","addEventListener","result","readAsArrayBuffer","File","name","type","startsWith","endsWith","contentEncoding","hash","mime","lookup","AssetManager","constructor","_ref","_this","this","concurrency","maxSingleFileSize","maxChunkSize","eventListener","actorConfig","_actor","_pLimit","_maxSingleFileSize","_maxChunkSize","_eventListener","batch","scheduledOperations","commit","all","map","scheduled_operation","flat","forEach","operation","insert","asset","join","progress","current","total","push","chunks","reduce","byte","chunkIndex","Math","floor","chunkIds","chunk","delete","Actor","createActor","idlFactory","pLimit"],"mappings":"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"}