{"version":3,"file":"index.module.mjs","sources":["../src/did/asset_canister.did.js","../src/index.ts","../src/did/index.js"],"sourcesContent":["export const idlFactory = ({IDL}) => {\n    const ClearArguments = IDL.Record({});\n    const BatchId = IDL.Nat;\n    const Key = IDL.Text;\n    const CreateAssetArguments = IDL.Record({\n        'key': Key,\n        'content_type': IDL.Text,\n    });\n    const UnsetAssetContentArguments = IDL.Record({\n        'key': Key,\n        'content_encoding': IDL.Text,\n    });\n    const DeleteAssetArguments = IDL.Record({'key': Key});\n    const ChunkId = IDL.Nat;\n    const SetAssetContentArguments = IDL.Record({\n        'key': Key,\n        'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\n        'chunk_ids': IDL.Vec(ChunkId),\n        'content_encoding': IDL.Text,\n    });\n    const BatchOperationKind = IDL.Variant({\n        'CreateAsset': CreateAssetArguments,\n        'UnsetAssetContent': UnsetAssetContentArguments,\n        'DeleteAsset': DeleteAssetArguments,\n        'SetAssetContent': SetAssetContentArguments,\n        'Clear': ClearArguments,\n    });\n    const HeaderField = IDL.Tuple(IDL.Text, IDL.Text);\n    const HttpRequest = IDL.Record({\n        'url': IDL.Text,\n        'method': IDL.Text,\n        'body': IDL.Vec(IDL.Nat8),\n        'headers': IDL.Vec(HeaderField),\n    });\n    const StreamingCallbackToken = IDL.Record({\n        'key': Key,\n        'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\n        'index': IDL.Nat,\n        'content_encoding': IDL.Text,\n    });\n    const StreamingCallbackHttpResponse = IDL.Record({\n        'token': IDL.Opt(StreamingCallbackToken),\n        'body': IDL.Vec(IDL.Nat8),\n    });\n    const StreamingStrategy = IDL.Variant({\n        'Callback': IDL.Record({\n            'token': StreamingCallbackToken,\n            'callback': IDL.Func(\n                [StreamingCallbackToken],\n                [IDL.Opt(StreamingCallbackHttpResponse)],\n                ['query'],\n            ),\n        }),\n    });\n    const HttpResponse = IDL.Record({\n        'body': IDL.Vec(IDL.Nat8),\n        'headers': IDL.Vec(HeaderField),\n        'streaming_strategy': IDL.Opt(StreamingStrategy),\n        'status_code': IDL.Nat16,\n    });\n    const Time = IDL.Int;\n    return IDL.Service({\n        'authorize': IDL.Func([IDL.Principal], [], []),\n        'clear': IDL.Func([ClearArguments], [], []),\n        'commit_batch': IDL.Func(\n            [\n                IDL.Record({\n                    'batch_id': BatchId,\n                    'operations': IDL.Vec(BatchOperationKind),\n                }),\n            ],\n            [],\n            [],\n        ),\n        'create_asset': IDL.Func([CreateAssetArguments], [], []),\n        'create_batch': IDL.Func(\n            [IDL.Record({})],\n            [IDL.Record({'batch_id': BatchId})],\n            [],\n        ),\n        'create_chunk': IDL.Func(\n            [IDL.Record({'content': IDL.Vec(IDL.Nat8), 'batch_id': BatchId})],\n            [IDL.Record({'chunk_id': ChunkId})],\n            [],\n        ),\n        'delete_asset': IDL.Func([DeleteAssetArguments], [], []),\n        'get': IDL.Func(\n            [IDL.Record({'key': Key, 'accept_encodings': IDL.Vec(IDL.Text)})],\n            [\n                IDL.Record({\n                    'content': IDL.Vec(IDL.Nat8),\n                    'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\n                    'content_type': IDL.Text,\n                    'content_encoding': IDL.Text,\n                    'total_length': IDL.Nat,\n                }),\n            ],\n            ['query'],\n        ),\n        'get_chunk': IDL.Func(\n            [\n                IDL.Record({\n                    'key': Key,\n                    'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\n                    'index': IDL.Nat,\n                    'content_encoding': IDL.Text,\n                }),\n            ],\n            [IDL.Record({'content': IDL.Vec(IDL.Nat8)})],\n            ['query'],\n        ),\n        'http_request': IDL.Func([HttpRequest], [HttpResponse], ['query']),\n        'http_request_streaming_callback': IDL.Func(\n            [StreamingCallbackToken],\n            [IDL.Opt(StreamingCallbackHttpResponse)],\n            ['query'],\n        ),\n        'list': IDL.Func(\n            [IDL.Record({})],\n            [\n                IDL.Vec(\n                    IDL.Record({\n                        'key': Key,\n                        'encodings': IDL.Vec(\n                            IDL.Record({\n                                'modified': Time,\n                                'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\n                                'length': IDL.Nat,\n                                'content_encoding': IDL.Text,\n                            })\n                        ),\n                        'content_type': IDL.Text,\n                    })\n                ),\n            ],\n            ['query'],\n        ),\n        'set_asset_content': IDL.Func([SetAssetContentArguments], [], []),\n        'store': IDL.Func(\n            [\n                IDL.Record({\n                    'key': Key,\n                    'content': IDL.Vec(IDL.Nat8),\n                    'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\n                    'content_type': IDL.Text,\n                    'content_encoding': IDL.Text,\n                }),\n            ],\n            [],\n            [],\n        ),\n        'unset_asset_content': IDL.Func([UnsetAssetContentArguments], [], []),\n    });\n};","import {ActorConfig, hash} from \"@dfinity/agent\";\nimport {assetCanister} from \"./did\";\nimport mime from \"mime-types\";\nimport pLimit, {LimitFunction} from \"p-limit\";\n\ntype AssetCanister = ReturnType<typeof assetCanister>;\n\ninterface AssetManagerConfig extends ActorConfig {\n    concurrency?: number;\n    maxSingleFileSize?: number;\n    maxChunkSize?: number;\n    eventListener?: (event: AssetEvent) => void;\n}\n\ninterface Asset {\n    fileName: string;\n    path: string;\n    content: number[];\n    contentType: string;\n    contentEncoding: 'identity' | 'gzip' | 'compress' | 'deflate' | 'br';\n    sha256?: number[];\n}\n\ninterface AssetInsert {\n    (file: File, options?: Omit<Asset, 'fileName' | 'content' | 'contentType' | 'contentEncoding'> & Partial<Pick<Asset, 'fileName' | 'contentType' | 'contentEncoding'>>): Promise<string>;\n\n    (bytes: Blob | number[] | Uint8Array, options: Omit<Asset, 'content' | 'contentType' | 'contentEncoding'> & Partial<Pick<Asset, 'contentType' | 'contentEncoding'>>): Promise<string>;\n}\n\ninterface FileToAsset {\n    (...args: Parameters<AssetInsert>): Promise<Asset>;\n}\n\ninterface InsertAssetEvent {\n    key: string;\n    type: 'insert';\n    progress: {\n        current: number;\n        total: number;\n    };\n}\n\ninterface DeleteAssetEvent {\n    key: string;\n    type: 'delete';\n}\n\ntype AssetEvent = InsertAssetEvent | DeleteAssetEvent;\n\nconst isBrowser =\n    typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n\nconst isNode =\n    typeof process !== \"undefined\" &&\n    process.versions != null &&\n    process.versions.node != null;\n\nconst isWebWorker =\n    typeof self === \"object\" &&\n    self.constructor &&\n    self.constructor.name === \"DedicatedWorkerGlobalScope\";\n\nconst inputToAsset: FileToAsset = async (input, options) => {\n    let content: number[];\n    let fileName: string = options?.fileName as any;\n    let contentType: string = options?.contentType as any;\n    let path: string = options?.path ?? '/';\n    if (input instanceof Uint8Array) {\n        content = Array.from(input);\n    } else if (Array.isArray(input) && input.every(b => typeof b === 'number')) {\n        content = input;\n    } else if (input instanceof Blob) {\n        content = await new Promise((resolve) => {\n            const reader = new FileReader();\n            reader.addEventListener('load', () => {\n                resolve(Array.from(Uint8Array.from(reader.result as any)));\n            });\n            reader.readAsArrayBuffer(input);\n        });\n        if (!fileName) {\n            if (input instanceof File) {\n                fileName = input.name;\n            } else {\n                throw '\"fileName\" property is required in options';\n            }\n        }\n        if (!contentType) {\n            contentType = input.type;\n        }\n    } else {\n        throw 'Asset could not be read (File, Blob, ArrayBuffer, Uint8Array and number[] are valid';\n    }\n    if (!path.startsWith('/')) {\n        path = '/' + path;\n    }\n    if (!path.endsWith('/')) {\n        path = path + '/';\n    }\n    const contentEncoding = options?.contentEncoding ?? 'identity';\n    const sha256 = options?.sha256 ?? Array.from(new Uint8Array(hash(new Uint8Array(content))));\n\n    // If content type is not supplied in either the file or options, detect content type based on filename (extension)\n    if (!contentType) {\n        contentType = mime.lookup(fileName) || 'application/octet-stream';\n    }\n\n    return {\n        fileName,\n        path,\n        content,\n        contentType,\n        contentEncoding,\n        sha256,\n    };\n};\n\nexport class AssetManager {\n    private readonly _actor: AssetCanister;\n    private readonly _pLimit: LimitFunction;\n    private readonly _maxSingleFileSize: number;\n    private readonly _maxChunkSize: number;\n    private readonly _eventListener: (event: AssetEvent) => void;\n\n    constructor({concurrency, maxSingleFileSize, maxChunkSize, eventListener, ...actorConfig}: AssetManagerConfig) {\n        this._actor = assetCanister(actorConfig);\n        this._pLimit = pLimit(concurrency ?? 32);\n        this._maxSingleFileSize = maxSingleFileSize ?? 450000;\n        this._maxChunkSize = maxChunkSize ?? 1900000;\n        this._eventListener = eventListener ?? (() => null);\n    }\n\n    list = () => this._pLimit(() => this._actor.list({}));\n\n    batch = () => {\n        const scheduledOperations: Array<(batch_id: bigint) => Promise<Parameters<AssetCanister['commit_batch']>[0]['operations']>> = [];\n        const commit = async () => {\n            const {batch_id} = await this._pLimit(() => this._actor.create_batch({}));\n            const operations = (await Promise.all(scheduledOperations.map(scheduled_operation => scheduled_operation(batch_id)))).flat();\n            await this._pLimit(() => this._actor.commit_batch({batch_id, operations}));\n            operations.forEach(operation => {\n                if ('DeleteAsset' in operation) {\n                    this._eventListener({key: operation.DeleteAsset.key, type: 'delete'});\n                }\n            })\n        };\n        const insert: AssetInsert = async (input, options) => {\n            const asset = await inputToAsset(input, options);\n            const key = [asset.path, asset.fileName].join('');\n            this._eventListener({key, type: 'insert', progress: {current: 0, total: asset.content.length}});\n            scheduledOperations.push(async batch_id => {\n                const chunks = asset.content.reduce((chunks, byte, index) => {\n                    const chunkIndex = Math.floor(index / this._maxChunkSize)\n                    if (!chunks[chunkIndex]) {\n                        chunks[chunkIndex] = [];\n                    }\n                    chunks[chunkIndex].push(byte)\n                    return chunks;\n                }, [] as number[][]);\n                let progress = 0;\n                const chunkIds: bigint[] = await Promise.all(chunks\n                    .map(async chunk => {\n                        const {chunk_id} = await this._pLimit(() => this._actor.create_chunk({\n                            content: chunk,\n                            batch_id\n                        }));\n                        progress += chunk.length;\n                        this._eventListener({\n                            key,\n                            type: 'insert',\n                            progress: {current: progress, total: asset.content.length}\n                        });\n                        return chunk_id;\n                    })\n                );\n                return [\n                    {\n                        CreateAsset: {key, content_type: asset.contentType}\n                    },\n                    {\n                        SetAssetContent: {\n                            key,\n                            sha256: asset.sha256 ? [asset.sha256] : [],\n                            chunk_ids: chunkIds,\n                            content_encoding: asset.contentEncoding\n                        }\n                    },\n                ];\n            });\n            return key;\n        }\n        const _delete = async (key: string) => {\n            scheduledOperations.push(async () => [{DeleteAsset: {key}}]);\n        }\n\n        return {commit, insert, delete: _delete};\n    }\n\n    insert: AssetInsert = async (input, options) => {\n        const asset = await inputToAsset(input, options);\n        const key = [asset.path, asset.fileName].join('');\n\n        if (asset.content.length <= this._maxSingleFileSize) {\n            // Asset is small enough to be uploaded in one request\n            this._eventListener({key, type: 'insert', progress: {current: 0, total: asset.content.length}});\n            await this._pLimit(() => this._actor.store({\n                key,\n                content: asset.content,\n                content_type: asset.contentType,\n                sha256: asset.sha256 ? [asset.sha256] : [],\n                content_encoding: asset.contentEncoding\n            }));\n        } else {\n            // Create batch to upload asset in chunks\n            const batch = this.batch();\n            await batch.insert(asset.content, asset);\n            await batch.commit();\n        }\n\n        return key;\n    };\n\n    delete = async (key: string) => {\n        await this._pLimit(() => this._actor.delete_asset({key}));\n        this._eventListener({key, type: 'delete'});\n    }\n}","import {idlFactory} from './asset_canister.did.js';\nimport {Actor} from \"@dfinity/agent\";\n\n/**\n * @type {(configuration: import(\"@dfinity/agent\").ActorConfig) => import(\"@dfinity/agent\").ActorSubclass<import(\"./asset_canister.did.js\")._SERVICE>}\n */\nexport const assetCanister = (configuration) => Actor.createActor(idlFactory, configuration);\n"],"names":["_ref","IDL","ClearArguments","Record","BatchId","Nat","Key","Text","CreateAssetArguments","key","content_type","UnsetAssetContentArguments","content_encoding","DeleteAssetArguments","ChunkId","SetAssetContentArguments","sha256","Opt","Vec","Nat8","chunk_ids","BatchOperationKind","Variant","CreateAsset","UnsetAssetContent","DeleteAsset","SetAssetContent","Clear","Tuple","HttpRequest","url","method","body","headers","HeaderField","StreamingCallbackToken","index","StreamingCallbackHttpResponse","token","StreamingStrategy","Callback","callback","Func","HttpResponse","streaming_strategy","status_code","Nat16","Time","Int","Service","authorize","Principal","clear","commit_batch","batch_id","operations","create_asset","create_batch","create_chunk","content","chunk_id","delete_asset","get","accept_encodings","total_length","get_chunk","http_request","http_request_streaming_callback","list","encodings","modified","length","set_asset_content","store","unset_asset_content","_excluded","process","versions","inputToAsset","input","options","_options$path","_temp3","_result3","_options$contentEncod","_options$sha","path","startsWith","endsWith","contentEncoding","Array","from","Uint8Array","hash","contentType","mime","lookup","fileName","isArray","every","b","Blob","Promise","resolve","reader","FileReader","addEventListener","result","readAsArrayBuffer","_Promise","File","name","type","_temp4","then","AssetManager","_this2","this","_this3","concurrency","maxSingleFileSize","maxChunkSize","eventListener","actorConfig","_objectWithoutPropertiesLoose","_actor","_pLimit","_maxSingleFileSize","_maxChunkSize","_eventListener","_this","batch","scheduledOperations","commit","_ref2","all","map","scheduled_operation","_Promise$all","flat","forEach","operation","e","reject","insert","asset","join","progress","current","total","push","chunks","reduce","byte","chunkIndex","Math","floor","chunk","_ref3","chunkIds","delete","_temp5","Actor","createActor","idlFactory","pLimit"],"mappings":"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"}